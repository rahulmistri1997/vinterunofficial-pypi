{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unofficial Wrapper for the Vinter API","text":"<p>This is an unofficial wrapper for the Vinter API. It is not affiliated with Vinter in any way.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install vinterunofficial\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>VinterAPIDocumentation</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#valid-assettype-api","title":"Valid AssetType API","text":"<ul> <li>single_assets</li> <li>multi_assets</li> <li>staking_yields</li> <li>nav</li> </ul>"},{"location":"#valid-assettype-websocket","title":"Valid AssetType Websocket","text":"<ul> <li>single_assets</li> <li>multi_assets</li> <li>nav</li> </ul>"},{"location":"#important-notes-about-the-library","title":"Important Notes About the Library","text":"<ul> <li>The library supports both synchronous and asynchronous requests.</li> <li>The library is still in development and may have bugs.</li> <li>All the methods are documented in the source code.</li> <li>All the methods are callable from both the synchronous and asynchronous classes.</li> <li>The asynchronous class is called VinterAPIAsync.</li> <li>The synchronous class is called VinterAPI.</li> <li>The asynchronous class repeats the same methods as the synchronous class, but can be called with the await keyword.</li> </ul>"},{"location":"#version-of-the-library","title":"Version of the Library","text":"<pre><code>import vinterunofficial\nprint(vinterunofficial.__version__)\n</code></pre>"},{"location":"#importing-the-library","title":"Importing the library","text":"<pre><code>from vinterunofficial import VinterAPI, VinterAPIAsync\n</code></pre>"},{"location":"#get-latest-data","title":"Get Latest Data","text":"<pre><code>from vinterunofficial import VinterAPI\nvinter = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"single_assets\")\nselected_symbol = \"btc-usd-p-d\"\n# Get the latest value of the asset\ndata = vinter.get_latest_data(selected_symbol, limit=1)\n# The returned data is a list of dictionaries as shown in the sample response in the documentation\n# You can also increase the limit to get more than one value which will return a list ordered by the latest to the oldest\ncurrent_price = data[0][\"value\"]\ncreated_at = data[0][\"created_at\"]\nprint(\"The current price of {} is {} at {}\".format(selected_symbol, current_price, created_at))\n</code></pre>"},{"location":"#get-historical-data-between-time-ranges","title":"Get Historical Data Between Time Ranges","text":"<pre><code>from vinterunofficial import VinterAPI\nvinter = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"single_assets\")\nselected_symbol = \"btc-usd-p-d\"\n# Get the latest value of the asset\ndata = vinter.get_data_by_time(symbol=selected_symbol, start=\"2023-01-01T00:00:00Z\", end=\"2023-01-05T23:59:59Z\")\n# The returned data is a list of dictionaries as shown in the sample response in the documentation\n# You can also increase the limit default is 1000, Max is 2000.\n# The returned order will be from oldest to latest so that its easier to loop through start time to get historical data in a paginated api responses.\nprint(f\"The Response : {data}\")\n</code></pre>"},{"location":"#if-you-just-want-the-latest-value","title":"If you just want the latest value","text":"<pre><code>from vinterunofficial import VinterAPI\nvinter = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"single_assets\")\nselected_symbol = \"btc-usd-p-d\"\n# Get the latest value of the asset\ncurrent_price = vinter.get_latest_value(selected_symbol)\nprint(\"The current price of {} is {}\".format(selected_symbol, current_price))\n</code></pre>"},{"location":"#get-all-active-symbols","title":"Get All Active Symbols","text":"<pre><code>from vinterunofficial import VinterAPI\nsingle_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"single_assets\")\nmulti_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"multi_assets\")\nall_active_symbol_multi = [asset[\"symbol\"] for asset in multi_assets.get_all_active_symbols()]\nall_active_symbol_single = [asset[\"symbol\"] for asset in single_assets.get_all_active_symbols()]\nprint(\"All active symbols for multi assets: {}\".format(all_active_symbol_multi))\nprint(\"All active symbols for single assets: {}\".format(all_active_symbol_single))\n</code></pre>"},{"location":"#get-contribution-of-single-asset","title":"Get Contribution of Single Asset","text":"<pre><code>from vinterunofficial import VinterAPI\nsingle_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"single_assets\")\nselected_symbol = \"btc-usd-p-r\"\nsingle_asset_contribution = single_assets.get_contributions(selected_symbol)\nprint(\"The contribution of {} is {}\".format(selected_symbol, single_asset_contribution))\n</code></pre>"},{"location":"#get-weight-of-multi-asset","title":"Get Weight of Multi Asset","text":"<pre><code>from vinterunofficial import VinterAPI\nmulti_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"multi_assets\")\nselected_symbol = \"vnby-bold1-2-d\"\nmulti_asset_weight = multi_assets.get_current_rebalance_weight(selected_symbol)\nprint(\"The weight of {} is {}\".format(selected_symbol, multi_asset_weight))\n</code></pre>"},{"location":"#get-next-rebalance-date-of-multi-asset","title":"Get Next Rebalance Date of Multi Asset","text":"<pre><code>from vinterunofficial import VinterAPI\nmulti_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"multi_assets\")\nselected_symbol = \"vnby-bold1-2-d\"\nnext_rebalance_date = multi_assets.get_next_rebalance_date(selected_symbol)\nprint(\"The next rebalance date of {} is {}\".format(selected_symbol, next_rebalance_date))\n</code></pre>"},{"location":"#get-previous-rebalance-date-of-multi-asset","title":"Get Previous Rebalance Date of Multi Asset","text":"<pre><code>from vinterunofficial import VinterAPI\nmulti_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"multi_assets\")\nselected_symbol = \"vnby-bold1-2-d\"\nprevious_rebalance_date = multi_assets.get_previous_rebalance_date(selected_symbol)\nprint(\"The previous rebalance date of {} is {}\".format(selected_symbol, previous_rebalance_date))\n</code></pre>"},{"location":"#get-next-review-date-of-multi-asset","title":"Get Next Review Date of Multi Asset","text":"<pre><code>from vinterunofficial import VinterAPI\nmulti_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"multi_assets\")\nselected_symbol = \"vnby-bold1-2-d\"\nnext_review_date = multi_assets.get_next_review_date(selected_symbol)\nprint(\"The next review date of {} is {}\".format(selected_symbol, next_review_date))\n</code></pre>"},{"location":"#get-previous-review-date-of-multi-asset","title":"Get Previous Review Date of Multi Asset","text":"<pre><code>from vinterunofficial import VinterAPI\nmulti_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"multi_assets\")\nselected_symbol = \"vnby-bold1-2-d\"\nprevious_review_date = multi_assets.get_previous_review_date(selected_symbol)\nprint(\"The previous review date of {} is {}\".format(selected_symbol, previous_review_date))\n</code></pre>"},{"location":"#get-next-rebalance-weight-of-multi-asset","title":"Get Next Rebalance Weight of Multi Asset","text":"<pre><code>from vinterunofficial import VinterAPI\nmulti_assets = VinterAPI(api_key=\"&lt;APIKey&gt;\", asset_type=\"multi_assets\")\nselected_symbol = \"vnby-bold1-2-d\"\nnext_rebalance_weight = multi_assets.get_next_rebalance_weight(selected_symbol)\nprint(\"The next rebalance weight of {} is {}\".format(selected_symbol, next_rebalance_weight))\n</code></pre>"},{"location":"#websocket","title":"Websocket","text":"<pre><code>from vinterunofficial import VinterAPIWS\ndef on_message(ws, message):\nprint(message)\n#ws.close() # Uncomment this line to close the websocket after receiving a message\ndef on_error(ws, error):\nprint(error)\ndef on_close(ws, close_status_code, close_msg):\nprint(\"### closed ###\")\nprint(f\"close_status_code: {close_status_code} close_msg: {close_msg}\")\ndef on_open(ws):\nprint(\"### open ###\")\nvinter_ws = VinterAPIWS(\nsymbol=\"btc-usd-p-r\",\ntoken=\"&lt;APIKey&gt;\",\nasset_type=\"single_assets\",\non_message=on_message,\non_error=on_error,\non_close=on_close,\non_open=on_open,\n)\nvinter_ws.open()\n</code></pre>"},{"location":"tests_doc/test_api/","title":"VinterSDK","text":""},{"location":"tests_doc/test_api/#tests.test_api.test_filter_by_symbol","title":"<code>test_filter_by_symbol()</code>","text":"<p>Test that _filter_by_symbol returns a list of dicts</p> Source code in <code>tests/test_api.py</code> <pre><code>def test_filter_by_symbol():\n\"\"\"\n    Test that _filter_by_symbol returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPI(api_key=api_key, asset_type=asset_type)\nsymbol = \"waves-usd-p-d\"\nexpected_output = [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n]\nmock_data = [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-d\", \"contrib\": [\"ton-usdt-p-r\"]},\n]\nresult = api._filter_by_symbol(mock_data, symbol)\nassert result == expected_output\n</code></pre>"},{"location":"tests_doc/test_api/#tests.test_api.test_get_all_active_symbols_async_returns_list","title":"<code>test_get_all_active_symbols_async_returns_list()</code>","text":"<p>Test that get_all_active_symbols returns a list of dicts</p> Source code in <code>tests/test_api.py</code> <pre><code>def test_get_all_active_symbols_async_returns_list():\n\"\"\"\n    Test that get_all_active_symbols returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPI(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.Client()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-d\", \"contrib\": [\"ton-usdt-p-r\"]},\n],\n\"params\": {},\n}\nexpected_output = mock_response[\"data\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=Mock) as mock_get:\nmock_get.return_value = Mock(json=Mock(return_value=mock_response))\nresult = api.get_all_active_symbols()\nassert result == expected_output\n</code></pre>"},{"location":"tests_doc/test_api/#tests.test_api.test_get_all_active_symbols_async_symbol_only_returns_symbol_list","title":"<code>test_get_all_active_symbols_async_symbol_only_returns_symbol_list()</code>","text":"<p>Test that get_all_active_symbols_async returns a list of dicts</p> Source code in <code>tests/test_api.py</code> <pre><code>def test_get_all_active_symbols_async_symbol_only_returns_symbol_list():\n\"\"\"\n    Test that get_all_active_symbols_async returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPI(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.Client()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-d\", \"contrib\": [\"ton-usdt-p-r\"]},\n],\n\"params\": {},\n}\nexpected_output = [\"waves-usd-p-d\", \"ton-usdt-p-5-d\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=Mock) as mock_get:\nmock_get.return_value = Mock(json=Mock(return_value=mock_response))\nresult = api.get_all_active_symbols(symbol_only=True)\nassert result == expected_output\n</code></pre>"},{"location":"tests_doc/test_api/#tests.test_api.test_get_all_active_symbols_async_with_frequency_returns_filtered_list","title":"<code>test_get_all_active_symbols_async_with_frequency_returns_filtered_list()</code>","text":"<p>Test that get_all_active_symbols_async returns a list of dicts</p> Source code in <code>tests/test_api.py</code> <pre><code>def test_get_all_active_symbols_async_with_frequency_returns_filtered_list():\n\"\"\"\n    Test that get_all_active_symbols_async returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPI(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.Client()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-r\", \"contrib\": [\"ton-usdt-p-r\"]},\n],\n\"params\": {},\n}\nexpected_output = [{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]}]\nwith patch.object(api.httpx_client, \"get\", new_callable=Mock) as mock_get:\nmock_get.return_value = Mock(json=Mock(return_value=mock_response))\nresult = api.get_all_active_symbols(frequency=\"d\")\nassert result == expected_output\n</code></pre>"},{"location":"tests_doc/test_api/#tests.test_api.test_get_latest_data_raises_exception","title":"<code>test_get_latest_data_raises_exception()</code>","text":"<p>Test that get_latest_data raises a ValueError</p> Source code in <code>tests/test_api.py</code> <pre><code>def test_get_latest_data_raises_exception():\n\"\"\"\n    Test that get_latest_data raises a ValueError\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"single_assets\"\napi = VinterAPI(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.Client()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [],\n\"params\": {\"symbol\": \"btc-usd-p-r\", \"limit\": 1},\n}\nexpected_output = mock_response[\"data\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=Mock) as mock_get:\nmock_get.return_value = Mock(json=Mock(return_value=mock_response))\nwith pytest.raises(ValueError):\napi.get_latest_data(\"btc-usd-p-r\")\n</code></pre>"},{"location":"tests_doc/test_api/#tests.test_api.test_get_latest_data_returns_dict","title":"<code>test_get_latest_data_returns_dict()</code>","text":"<p>Test that get_latest_data returns a dict</p> Source code in <code>tests/test_api.py</code> <pre><code>def test_get_latest_data_returns_dict():\n\"\"\"\n    Test that get_latest_data returns a dict\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"single_assets\"\napi = VinterAPI(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.Client()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\n\"symbol\": \"btc-usd-p-r\",\n\"timestamp\": 1647724800,\n}\n],\n\"params\": {\"symbol\": \"btc-usd-p-r\", \"limit\": 1},\n}\nexpected_output = mock_response[\"data\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=Mock) as mock_get:\nmock_get.return_value = Mock(json=Mock(return_value=mock_response))\nresult = api.get_latest_data(\"btc-usd-p-r\")\nassert result == expected_output\n</code></pre>"},{"location":"tests_doc/test_api/#tests.test_api.test_get_latest_value","title":"<code>test_get_latest_value()</code>","text":"<p>Test that get_latest_value returns a float</p> Source code in <code>tests/test_api.py</code> <pre><code>def test_get_latest_value():\n\"\"\"\n    Test that get_latest_value returns a float\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"single_assets\"\napi = VinterAPI(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.Client()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [{\"symbol\": \"btc-usd-p-r\", \"timestamp\": 1647724800, \"value\": 1000}],\n\"params\": {\"symbol\": \"btc-usd-p-r\", \"limit\": 1},\n}\nexpected_output = mock_response[\"data\"][0][\"value\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=Mock) as mock_get:\nmock_get.return_value = Mock(json=Mock(return_value=mock_response))\nresult = api.get_latest_value(\"btc-usd-p-r\")\nassert result == expected_output\n</code></pre>"},{"location":"tests_doc/test_async_api/","title":"Vinter SDK Async","text":""},{"location":"tests_doc/test_async_api/#tests.test_async_api.test_filter_by_symbol","title":"<code>test_filter_by_symbol()</code>","text":"<p>Test that _filter_by_symbol returns a list of dicts</p> Source code in <code>tests/test_async_api.py</code> <pre><code>def test_filter_by_symbol():\n\"\"\"\n    Test that _filter_by_symbol returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPIAsync(api_key=api_key, asset_type=asset_type)\nsymbol = \"waves-usd-p-d\"\nexpected_output = [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n]\nmock_data = [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-d\", \"contrib\": [\"ton-usdt-p-r\"]},\n]\nresult = api._filter_by_symbol(mock_data, symbol)\nassert result == expected_output\n</code></pre>"},{"location":"tests_doc/test_async_api/#tests.test_async_api.test_get_all_active_symbols_async_returns_list","title":"<code>test_get_all_active_symbols_async_returns_list()</code>  <code>async</code>","text":"<p>Test that get_all_active_symbols returns a list of dicts</p> Source code in <code>tests/test_async_api.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_get_all_active_symbols_async_returns_list():\n\"\"\"\n    Test that get_all_active_symbols returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPIAsync(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.AsyncClient()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-d\", \"contrib\": [\"ton-usdt-p-r\"]},\n],\n\"params\": {},\n}\nexpected_output = mock_response[\"data\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=AsyncMock) as mock_get:\nmock_get.return_value = AsyncMock(json=Mock(return_value=mock_response))\nresult = await api.get_all_active_symbols()\nassert result == expected_output\nawait api.httpx_client.aclose()\n</code></pre>"},{"location":"tests_doc/test_async_api/#tests.test_async_api.test_get_all_active_symbols_async_symbol_only_returns_symbol_list","title":"<code>test_get_all_active_symbols_async_symbol_only_returns_symbol_list()</code>  <code>async</code>","text":"<p>Test that get_all_active_symbols_async returns a list of dicts</p> Source code in <code>tests/test_async_api.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_get_all_active_symbols_async_symbol_only_returns_symbol_list():\n\"\"\"\n    Test that get_all_active_symbols_async returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPIAsync(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.AsyncClient()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-d\", \"contrib\": [\"ton-usdt-p-r\"]},\n],\n\"params\": {},\n}\nexpected_output = [\"waves-usd-p-d\", \"ton-usdt-p-5-d\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=AsyncMock) as mock_get:\nmock_get.return_value = AsyncMock(json=Mock(return_value=mock_response))\nresult = await api.get_all_active_symbols(symbol_only=True)\nassert result == expected_output\nawait api.httpx_client.aclose()\n</code></pre>"},{"location":"tests_doc/test_async_api/#tests.test_async_api.test_get_all_active_symbols_async_with_frequency_returns_filtered_list","title":"<code>test_get_all_active_symbols_async_with_frequency_returns_filtered_list()</code>  <code>async</code>","text":"<p>Test that get_all_active_symbols_async returns a list of dicts</p> Source code in <code>tests/test_async_api.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_get_all_active_symbols_async_with_frequency_returns_filtered_list():\n\"\"\"\n    Test that get_all_active_symbols_async returns a list of dicts\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"multi_assets\"\napi = VinterAPIAsync(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.AsyncClient()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]},\n{\"symbol\": \"ton-usdt-p-5-r\", \"contrib\": [\"ton-usdt-p-r\"]},\n],\n\"params\": {},\n}\nexpected_output = [{\"symbol\": \"waves-usd-p-d\", \"contrib\": [\"waves-usd-p-r\"]}]\nwith patch.object(api.httpx_client, \"get\", new_callable=AsyncMock) as mock_get:\nmock_get.return_value = AsyncMock(json=Mock(return_value=mock_response))\nresult = await api.get_all_active_symbols(frequency=\"d\")\nassert result == expected_output\nawait api.httpx_client.aclose()\n</code></pre>"},{"location":"tests_doc/test_async_api/#tests.test_async_api.test_get_latest_data_raises_exception","title":"<code>test_get_latest_data_raises_exception()</code>  <code>async</code>","text":"<p>Test that get_latest_data raises a ValueError</p> Source code in <code>tests/test_async_api.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_get_latest_data_raises_exception():\n\"\"\"\n    Test that get_latest_data raises a ValueError\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"single_assets\"\napi = VinterAPIAsync(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.AsyncClient()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [],\n\"params\": {\"symbol\": \"btc-usd-p-r\", \"limit\": 1},\n}\nexpected_output = mock_response[\"data\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=AsyncMock) as mock_get:\nmock_get.return_value = AsyncMock(json=Mock(return_value=mock_response))\nwith pytest.raises(ValueError):\nawait api.get_latest_data(\"btc-usd-p-r\")\nawait api.httpx_client.aclose()\n</code></pre>"},{"location":"tests_doc/test_async_api/#tests.test_async_api.test_get_latest_data_returns_dict","title":"<code>test_get_latest_data_returns_dict()</code>  <code>async</code>","text":"<p>Test that get_latest_data returns a dict</p> Source code in <code>tests/test_async_api.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_get_latest_data_returns_dict():\n\"\"\"\n    Test that get_latest_data returns a dict\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"single_assets\"\napi = VinterAPIAsync(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.AsyncClient()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [\n{\n\"symbol\": \"btc-usd-p-r\",\n\"timestamp\": 1647724800,\n}\n],\n\"params\": {\"symbol\": \"btc-usd-p-r\", \"limit\": 1},\n}\nexpected_output = mock_response[\"data\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=AsyncMock) as mock_get:\nmock_get.return_value = AsyncMock(json=Mock(return_value=mock_response))\nresult = await api.get_latest_data(\"btc-usd-p-r\")\nassert result == expected_output\nawait api.httpx_client.aclose()\n</code></pre>"},{"location":"tests_doc/test_async_api/#tests.test_async_api.test_get_latest_value","title":"<code>test_get_latest_value()</code>  <code>async</code>","text":"<p>Test that get_latest_value returns a float</p> Source code in <code>tests/test_async_api.py</code> <pre><code>@pytest.mark.asyncio\nasync def test_get_latest_value():\n\"\"\"\n    Test that get_latest_value returns a float\n    \"\"\"\napi_key = \"my_api_key\"\nasset_type = \"single_assets\"\napi = VinterAPIAsync(api_key=api_key, asset_type=asset_type)\napi.httpx_client = httpx.AsyncClient()\nmock_response = {\n\"result\": \"success\",\n\"message\": \"Success\",\n\"data\": [{\"symbol\": \"btc-usd-p-r\", \"timestamp\": 1647724800, \"value\": 1000}],\n\"params\": {\"symbol\": \"btc-usd-p-r\", \"limit\": 1},\n}\nexpected_output = mock_response[\"data\"][0][\"value\"]\nwith patch.object(api.httpx_client, \"get\", new_callable=AsyncMock) as mock_get:\nmock_get.return_value = AsyncMock(json=Mock(return_value=mock_response))\nresult = await api.get_latest_value(\"btc-usd-p-r\")\nassert result == expected_output\nawait api.httpx_client.aclose()\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/","title":"Test Vinter Utils","text":""},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_classess","title":"<code>test_classess()</code>","text":"<p>This function tests the classes in the vinter_validation.py and vinter_url.py files</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_classess():\n''' This function tests the classes in the vinter_validation.py and vinter_url.py files\n    '''\nvinter_validation = VinterValidation()\nvinter_url = VinterUrl()\nassert vinter_validation is not None\nassert vinter_url is not None\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_active_url","title":"<code>test_get_active_url()</code>","text":"<p>The function <code>get_active_url</code> takes an asset type as a string and returns the url for the active assets of that type.</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_active_url():\n'''&gt; The function `get_active_url` takes an asset type as a string and returns the url for the active\n    assets of that type.\n    '''\nasset_type = \"multi_assets\"\nurl = VinterUrl.get_active_url(asset_type)\nassert url == f\"https://www.vinterapi.com/api/v3/active_{asset_type}\"\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_active_url_invalid_asset_type","title":"<code>test_get_active_url_invalid_asset_type()</code>","text":"<p><code>get_active_url</code> returns the active url for the given asset type</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_active_url_invalid_asset_type():\n'''`get_active_url` returns the active url for the given asset type\n    '''\nasset_type = \"invalid_asset_type\"\nwith pytest.raises(ValueError):\nVinterUrl.get_active_url(asset_type)\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_url","title":"<code>test_get_url()</code>","text":"<p>The function <code>get_url</code> takes two arguments, <code>asset_type</code> and <code>frequency</code>, and returns a string that is the url for the Vinter API</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_url():\n'''&gt; The function `get_url` takes two arguments, `asset_type` and `frequency`, and returns a string\n    that is the url for the Vinter API\n    '''\nasset_type = \"multi_assets\"\nfrequency = \"d\"\nurl = VinterUrl.get_url(asset_type, frequency)\nassert url == f\"https://www.vinterapi.com/api/v3/{asset_type}_daily\"\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_url_by_symbol","title":"<code>test_get_url_by_symbol()</code>","text":"<p>Given an asset type and a symbol, return the url for the corresponding API endpoint</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_url_by_symbol():\n'''&gt; Given an asset type and a symbol, return the url for the corresponding API endpoint\n    '''\nasset_type = \"single_assets\"\nsymbol = \"btc-usd-p-d\"\nurl = VinterUrl.get_url_by_symbol(asset_type, symbol)\nassert url == f\"https://www.vinterapi.com/api/v3/single_assets_daily\"\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_url_invalid_asset_type","title":"<code>test_get_url_invalid_asset_type()</code>","text":"<p>It tests that the function <code>get_url</code> raises a <code>ValueError</code> when an invalid asset type is passed to it</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_url_invalid_asset_type():\n'''It tests that the function `get_url` raises a `ValueError` when an invalid asset type is passed to\n    it\n    '''\nasset_type = \"invalid_asset_type\"\nfrequency = \"d\"\nwith pytest.raises(ValueError):\nVinterUrl.get_url(asset_type, frequency)\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_websocket_url","title":"<code>test_get_websocket_url()</code>","text":"<p>Given an asset type and a symbol, return the url for the corresponding websocket endpoint</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_websocket_url():\n'''&gt; Given an asset type and a symbol, return the url for the corresponding websocket endpoint\n    '''\nasset_type = \"single_assets\"\nsymbol = \"btc-usd-p-d\"\nurl = VinterUrl.websocket_url(asset_type, symbol)\nassert url == f\"wss://www.vinterapi.com/ws/singleassets/{symbol}\"\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_websocket_url_invalid_asset_type","title":"<code>test_get_websocket_url_invalid_asset_type()</code>","text":"<p>It tests that the function <code>get_websocket_url</code> raises a <code>ValueError</code> when an invalid asset type is passed to it</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_websocket_url_invalid_asset_type():\n'''It tests that the function `get_websocket_url` raises a `ValueError` when an invalid asset type is\n    passed to it\n    '''\nasset_type = \"invalid_asset_type\"\nsymbol = \"btc-usd-p-d\"\nwith pytest.raises(ValueError):\nVinterUrl.websocket_url(asset_type, symbol)\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_get_websocket_url_no_symbol","title":"<code>test_get_websocket_url_no_symbol()</code>","text":"<p>It tests that the function <code>get_websocket_url</code> raises a <code>ValueError</code> when no symbol is passed to it</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_get_websocket_url_no_symbol():\n'''It tests that the function `get_websocket_url` raises a `ValueError` when no symbol is passed to\n    it\n    '''\nasset_type = \"single_assets\"\nsymbol = None\nwith pytest.raises(ValueError):\nVinterUrl.websocket_url(asset_type, symbol)\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_invalid_asset_type","title":"<code>test_invalid_asset_type()</code>","text":"<p><code>test_invalid_asset_type</code> tests that the <code>validate_asset_type</code> function raises a <code>ValueError</code> when an invalid asset type is passed to it</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_invalid_asset_type():\n'''`test_invalid_asset_type` tests that the `validate_asset_type` function raises a `ValueError` when\n    an invalid asset type is passed to it\n    '''\nwith pytest.raises(ValueError):\nVinterValidation.validate_asset_type(\"invalid_asset\")\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_invalid_frequency","title":"<code>test_invalid_frequency()</code>","text":"<p>It raises a ValueError if the frequency is not one of the valid frequencies</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_invalid_frequency():\n'''It raises a ValueError if the frequency is not one of the valid frequencies\n    '''\nwith pytest.raises(ValueError):\nVinterValidation.validate_frequency(\"invalid_frequency\")\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_invalid_symbol","title":"<code>test_invalid_symbol()</code>","text":"<p>It raises a ValueError if the symbol is not a valid symbol</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_invalid_symbol():\n'''It raises a ValueError if the symbol is not a valid symbol\n    '''\nwith pytest.raises(ValueError):\nVinterValidation.validate_symbol_frequency(\"invalid_symbol\")\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_valid_asset_type","title":"<code>test_valid_asset_type()</code>","text":"<p>This function checks if the asset type is valid</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_valid_asset_type():\n''' This function checks if the asset type is valid\n    '''\nvalid_asset = \"multi_assets\"\nassert VinterValidation.validate_asset_type(valid_asset) is None\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_valid_frequency","title":"<code>test_valid_frequency()</code>","text":"<p>This function tests that a valid frequency is accepted</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_valid_frequency():\n'''&gt; This function tests that a valid frequency is accepted\n    '''\nvalid_frequency = \"d\"\nassert VinterValidation.validate_frequency(valid_frequency) is None\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_valid_symbol","title":"<code>test_valid_symbol()</code>","text":"<p><code>validate_symbol_frequency</code> takes a string as input and returns a tuple of two strings. The first string is the symbol and the second string is the frequency</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_valid_symbol():\n'''`validate_symbol_frequency` takes a string as input and returns a tuple of two strings. The first\n    string is the symbol and the second string is the frequency\n    '''\nvalid_symbol = \"btc-usd-p-d\"\nfreq = \"d\"\nassert VinterValidation.validate_symbol_frequency(valid_symbol) == (valid_symbol, freq)\n</code></pre>"},{"location":"tests_doc/test_vinter_utils/#tests.test_vinter_utils.test_validate_dates","title":"<code>test_validate_dates()</code>","text":"<p>It tests that the function <code>validate_dates</code> raises an error when it should, and doesn't raise an error when it shouldn't</p> Source code in <code>tests/test_vinter_utils.py</code> <pre><code>def test_validate_dates():\n'''It tests that the function `validate_dates` raises an error when it should, and doesn't raise an\n    error when it shouldn't\n    '''\n# Test a list of valid dates\nvalid_dates = [\"2022-03-18\", \"2022-03-19\", \"2022-03-20\"]\nVinterValidation.validate_dates(valid_dates)  # Should not raise an error\n# Test a list with an invalid date\ninvalid_dates = [\"2022-03-18\", \"2022-03-19\", \"invalid_date\"]\nwith pytest.raises(ValueError) as e:\nVinterValidation.validate_dates(invalid_dates)\nassert \"The date must be in the format YYYY-MM-DD\" in str(e.value)\n# Test an empty list\nempty_list = []\nVinterValidation.validate_dates(empty_list)  # Should not raise an error\n</code></pre>"},{"location":"tests_doc/test_ws/","title":"Websocket Test","text":""},{"location":"tests_doc/test_ws/#tests.test_ws.test_validate_class","title":"<code>test_validate_class()</code>","text":"<p>This function tests the classes in the vinter_validation.py and vinter_url.py files</p> Source code in <code>tests/test_ws.py</code> <pre><code>def test_validate_class():\n''' This function tests the classes in the vinter_validation.py and vinter_url.py files\n    '''\ndef on_message(ws, message):\npass\ndef on_error(ws, error):\npass\ndef on_close(ws, close_status_code, close_msg):\npass\ndef on_open(ws):\npass\nvinter_api_ws = VinterAPIWS(\nsymbol=\"btc-usd-p-d\",\ntoken=\"\",\nasset_type=\"multi_assets\",\non_message=on_message,\non_error=on_error,\non_close=on_close,\non_open=on_open,\n)\nassert vinter_api_ws is not None\nvinter_api_ws.open()\nvinter_api_ws.close()\n</code></pre>"},{"location":"vinterunofficial_doc/config/","title":"config.py","text":""},{"location":"vinterunofficial_doc/utils/","title":"utils.py","text":""},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl","title":"<code>VinterUrl</code>","text":"Source code in <code>vinterunofficial/utils.py</code> <pre><code>class VinterUrl:\ndef __init__(self):\npass\n@staticmethod\ndef get_active_url(asset_type: str) -&gt; str:\n\"\"\"This function returns the url to use to get the data\"\"\"\nurl = None\nfor asset_url in AssetUrl:\nif (\nasset_url.value[\"asset_type\"].value == asset_type\nand asset_url.value[\"frequency\"] is None\n):\nurl = asset_url.value[\"url\"]\nbreak\nif url is None:\nraise ValueError(f\"The asset type must be in {asset_type}\")\nreturn url\n@staticmethod\ndef get_url(asset_type: str, frequency: str = None) -&gt; str:\n\"\"\"It takes in an asset type and a frequency and returns a url\n        Parameters\n        ----------\n        asset_type : str\n            str\n        frequency : str\n            str = None\n        Returns\n        -------\n            The url is being returned.\n        \"\"\"\nasset_types = [asset_type.value for asset_type in AssetType]\nurl = None\nfor asset_url in AssetUrl:\nif (\nasset_url.value[\"asset_type\"].value == asset_type\nand asset_url.value[\"frequency\"].value == frequency\n):\nurl = asset_url.value[\"url\"]\nbreak\nif url is None:\nraise ValueError(f\"The asset type must be in {asset_types}\")\nreturn url\n@staticmethod\ndef get_url_by_symbol(asset_type: str, symbol: str) -&gt; str:\n\"\"\"It takes in an asset type and a symbol and returns a url\n        Parameters\n        ----------\n        asset_type : str\n            str\n        symbol : str\n            str\n        Returns\n        -------\n            The url is being returned.\n        \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nurl = VinterUrl.get_url(asset_type=asset_type, frequency=frequency)\nreturn url\n@staticmethod\ndef websocket_url(asset_type: str, symbol: str = None) -&gt; str:\n\"\"\"It takes in an asset type and a frequency and returns a websocket url\n        Parameters\n        ----------\n        asset_type : str\n            str\n        frequency : str\n            str = None\n        Returns\n        -------\n            The websocket url is being returned.\n        \"\"\"\nws_asset_types = [asset_type.value for asset_type in WsAssetType]\nif symbol is None:\nraise ValueError(\"The symbol must be provided.\")\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nurl = None\nfor asset_url in WsAssetUrl:\nif asset_url.value[\"asset_type\"].value == asset_type:\nurl = asset_url.value[\"url\"]\nurl = url + \"/\" + symbol\nbreak\nif url is None:\nraise ValueError(f\"The asset type must be in {ws_asset_types}\")\nreturn url\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.get_active_url","title":"<code>get_active_url(asset_type)</code>  <code>staticmethod</code>","text":"<p>This function returns the url to use to get the data</p> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef get_active_url(asset_type: str) -&gt; str:\n\"\"\"This function returns the url to use to get the data\"\"\"\nurl = None\nfor asset_url in AssetUrl:\nif (\nasset_url.value[\"asset_type\"].value == asset_type\nand asset_url.value[\"frequency\"] is None\n):\nurl = asset_url.value[\"url\"]\nbreak\nif url is None:\nraise ValueError(f\"The asset type must be in {asset_type}\")\nreturn url\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.get_url","title":"<code>get_url(asset_type, frequency=None)</code>  <code>staticmethod</code>","text":"<p>It takes in an asset type and a frequency and returns a url</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.get_url--parameters","title":"Parameters","text":"str <p>str</p> str <p>str = None</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.get_url--returns","title":"Returns","text":"<pre><code>The url is being returned.\n</code></pre> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef get_url(asset_type: str, frequency: str = None) -&gt; str:\n\"\"\"It takes in an asset type and a frequency and returns a url\n    Parameters\n    ----------\n    asset_type : str\n        str\n    frequency : str\n        str = None\n    Returns\n    -------\n        The url is being returned.\n    \"\"\"\nasset_types = [asset_type.value for asset_type in AssetType]\nurl = None\nfor asset_url in AssetUrl:\nif (\nasset_url.value[\"asset_type\"].value == asset_type\nand asset_url.value[\"frequency\"].value == frequency\n):\nurl = asset_url.value[\"url\"]\nbreak\nif url is None:\nraise ValueError(f\"The asset type must be in {asset_types}\")\nreturn url\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.get_url_by_symbol","title":"<code>get_url_by_symbol(asset_type, symbol)</code>  <code>staticmethod</code>","text":"<p>It takes in an asset type and a symbol and returns a url</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.get_url_by_symbol--parameters","title":"Parameters","text":"str <p>str</p> str <p>str</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.get_url_by_symbol--returns","title":"Returns","text":"<pre><code>The url is being returned.\n</code></pre> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef get_url_by_symbol(asset_type: str, symbol: str) -&gt; str:\n\"\"\"It takes in an asset type and a symbol and returns a url\n    Parameters\n    ----------\n    asset_type : str\n        str\n    symbol : str\n        str\n    Returns\n    -------\n        The url is being returned.\n    \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nurl = VinterUrl.get_url(asset_type=asset_type, frequency=frequency)\nreturn url\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.websocket_url","title":"<code>websocket_url(asset_type, symbol=None)</code>  <code>staticmethod</code>","text":"<p>It takes in an asset type and a frequency and returns a websocket url</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.websocket_url--parameters","title":"Parameters","text":"str <p>str</p> str <p>str = None</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterUrl.websocket_url--returns","title":"Returns","text":"<pre><code>The websocket url is being returned.\n</code></pre> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef websocket_url(asset_type: str, symbol: str = None) -&gt; str:\n\"\"\"It takes in an asset type and a frequency and returns a websocket url\n    Parameters\n    ----------\n    asset_type : str\n        str\n    frequency : str\n        str = None\n    Returns\n    -------\n        The websocket url is being returned.\n    \"\"\"\nws_asset_types = [asset_type.value for asset_type in WsAssetType]\nif symbol is None:\nraise ValueError(\"The symbol must be provided.\")\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nurl = None\nfor asset_url in WsAssetUrl:\nif asset_url.value[\"asset_type\"].value == asset_type:\nurl = asset_url.value[\"url\"]\nurl = url + \"/\" + symbol\nbreak\nif url is None:\nraise ValueError(f\"The asset type must be in {ws_asset_types}\")\nreturn url\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation","title":"<code>VinterValidation</code>","text":"Source code in <code>vinterunofficial/utils.py</code> <pre><code>class VinterValidation:\ndef __init__(self) -&gt; None:\npass\n@staticmethod\ndef validate_asset_type(asset_type: str) -&gt; None:\n\"\"\"If the asset type is not a valid asset_type , then raise a\n        ValueError\n        Parameters\n        ----------\n        asset_type : str\n            The type of asset you want to get data for.\n        \"\"\"\nvalid_asset_types = [asset_type.value for asset_type in AssetType]\nif asset_type not in valid_asset_types:\nraise ValueError(\nf\"The asset type must be one of the following : {valid_asset_types}\"\n)\n@staticmethod\ndef validate_frequency(frequency: str) -&gt; None:\n\"\"\"If the frequency is not a valid frequency, then raise a\n        ValueError\n        Parameters\n        ----------\n        frequency : str\n            The frequency of the asset you want to get data for.\n        \"\"\"\nfrequencies = [frequency.value for frequency in Frequency]\nif frequency not in frequencies:\nraise ValueError(\n\"The frequency must be one of the following valid frequencies: {}\".format(\nfrequencies\n)\n)\n@staticmethod\ndef validate_symbol_frequency(symbol: str) -&gt; tuple:\n\"\"\"It takes a string, splits it on the hyphen, and validates the last part of the string\n        Parameters\n        ----------\n        symbol : str\n            str\n        Returns\n        -------\n            A tuple of the symbol and the frequency.\n        \"\"\"\nsym_frequency = symbol.split(\"-\")[-1]\nVinterValidation.validate_frequency(sym_frequency)\nreturn symbol, sym_frequency\n@staticmethod\ndef validate_dates(dates: list) -&gt; None:\n\"\"\"It raises a ValueError if any of the dates in the dates list are not in the format YYYY-MM-DD\n        Parameters\n        ----------\n        dates\n            A list of dates in the format YYYY-MM-DD\n        \"\"\"\nfor date in dates:\n# Validate that the date is a valid date\ntry:\ndatetime.strptime(date, \"%Y-%m-%d\")\nexcept ValueError as e:\ne.args = (\n\"The date must be in the format YYYY-MM-DD. The date: {} is not in the correct format.\".format(\ndate\n),\n)\nraise\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_asset_type","title":"<code>validate_asset_type(asset_type)</code>  <code>staticmethod</code>","text":"<p>If the asset type is not a valid asset_type , then raise a ValueError</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_asset_type--parameters","title":"Parameters","text":"str <p>The type of asset you want to get data for.</p> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef validate_asset_type(asset_type: str) -&gt; None:\n\"\"\"If the asset type is not a valid asset_type , then raise a\n    ValueError\n    Parameters\n    ----------\n    asset_type : str\n        The type of asset you want to get data for.\n    \"\"\"\nvalid_asset_types = [asset_type.value for asset_type in AssetType]\nif asset_type not in valid_asset_types:\nraise ValueError(\nf\"The asset type must be one of the following : {valid_asset_types}\"\n)\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_dates","title":"<code>validate_dates(dates)</code>  <code>staticmethod</code>","text":"<p>It raises a ValueError if any of the dates in the dates list are not in the format YYYY-MM-DD</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_dates--parameters","title":"Parameters","text":"<p>dates     A list of dates in the format YYYY-MM-DD</p> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef validate_dates(dates: list) -&gt; None:\n\"\"\"It raises a ValueError if any of the dates in the dates list are not in the format YYYY-MM-DD\n    Parameters\n    ----------\n    dates\n        A list of dates in the format YYYY-MM-DD\n    \"\"\"\nfor date in dates:\n# Validate that the date is a valid date\ntry:\ndatetime.strptime(date, \"%Y-%m-%d\")\nexcept ValueError as e:\ne.args = (\n\"The date must be in the format YYYY-MM-DD. The date: {} is not in the correct format.\".format(\ndate\n),\n)\nraise\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_frequency","title":"<code>validate_frequency(frequency)</code>  <code>staticmethod</code>","text":"<p>If the frequency is not a valid frequency, then raise a ValueError</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_frequency--parameters","title":"Parameters","text":"str <p>The frequency of the asset you want to get data for.</p> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef validate_frequency(frequency: str) -&gt; None:\n\"\"\"If the frequency is not a valid frequency, then raise a\n    ValueError\n    Parameters\n    ----------\n    frequency : str\n        The frequency of the asset you want to get data for.\n    \"\"\"\nfrequencies = [frequency.value for frequency in Frequency]\nif frequency not in frequencies:\nraise ValueError(\n\"The frequency must be one of the following valid frequencies: {}\".format(\nfrequencies\n)\n)\n</code></pre>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_symbol_frequency","title":"<code>validate_symbol_frequency(symbol)</code>  <code>staticmethod</code>","text":"<p>It takes a string, splits it on the hyphen, and validates the last part of the string</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_symbol_frequency--parameters","title":"Parameters","text":"str <p>str</p>"},{"location":"vinterunofficial_doc/utils/#vinterunofficial.utils.VinterValidation.validate_symbol_frequency--returns","title":"Returns","text":"<pre><code>A tuple of the symbol and the frequency.\n</code></pre> Source code in <code>vinterunofficial/utils.py</code> <pre><code>@staticmethod\ndef validate_symbol_frequency(symbol: str) -&gt; tuple:\n\"\"\"It takes a string, splits it on the hyphen, and validates the last part of the string\n    Parameters\n    ----------\n    symbol : str\n        str\n    Returns\n    -------\n        A tuple of the symbol and the frequency.\n    \"\"\"\nsym_frequency = symbol.split(\"-\")[-1]\nVinterValidation.validate_frequency(sym_frequency)\nreturn symbol, sym_frequency\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/","title":"vinter_abc.py","text":""},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC","title":"<code>VinterAPIABC</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>class VinterAPIABC(ABC):\n@abstractmethod\ndef __init__(self, api_key: str, asset_type: str):  # pragma: no cover\n\"\"\"This function takes in an api_key and asset_type and sets them as attributes of the class\n        Parameters\n        ----------\n        api_key : str\n            Your API key.\n        asset_type : str\n            The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.\n        \"\"\"\npass\n@abstractmethod\ndef get_all_active_symbols(\nself, frequency: str = None, symbol_only: bool = False\n) -&gt; Union[list, dict]:  # pragma: no cover\n\"\"\"This function returns a dictionary of all the active symbols\n        Returns\n        -------\n            A dictionary of all the active symbols\n        \"\"\"\npass\n@abstractmethod\ndef get_latest_data(self, symbol: str, limit: int = 1) -&gt; dict:  # pragma: no cover\n\"\"\"It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for\n        that symbol\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        limit : int\n            The number of data points to return.\n        Returns\n        -------\n            A dictionary of the latest data for the symbol and limit.\n        \"\"\"\npass\n@abstractmethod\ndef get_latest_value(self, symbol: str) -&gt; float:  # pragma: no cover\n\"\"\"This function takes in a symbol and returns the latest value for that symbol\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            The latest value for the symbol\n        \"\"\"\npass\n@abstractmethod\ndef _filter_by_symbol(self, data: list, symbol: str) -&gt; list:  # pragma: no cover\n\"\"\"This function takes in a list of data and a symbol and returns a list of data for that symbol\n        Parameters\n        ----------\n        data : list\n            A list of data\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            A list of data for the symbol\n        \"\"\"\npass\n@abstractmethod\ndef _get_active_asset_data(self, symbol: str) -&gt; dict:  # pragma: no cover\n\"\"\"This function returns the data for the active asset\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            A dictionary of the data for the active asset\n        \"\"\"\npass\n@abstractmethod\ndef get_current_rebalance_weight(self, symbol: str) -&gt; dict:  # pragma: no cover\n\"\"\"This function returns the current rebalance weight of multi_assets symbol\n        Returns\n        -------\n            Weight of the current rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        \"\"\"\npass\n@abstractmethod\ndef get_contributions(self, symbol: str) -&gt; dict:  # pragma: no cover\n\"\"\"This function returns the contributions of the single_assets symbol\n        Returns\n        -------\n            A dictionary of the contributions of the single_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n        \"\"\"\npass\n@abstractmethod\ndef get_previous_rebalance_date(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the previous rebalance date of multi_assets symbol\n        Returns\n        -------\n            Date of the previous rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not scheduled\n        \"\"\"\npass\n@abstractmethod\ndef get_previous_review_date(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the previous review date of multi_assets symbol\n        Returns\n        -------\n            Date of the previous review of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Review is not scheduled\n        \"\"\"\npass\n@abstractmethod\ndef get_next_review_date(self, symbol: str) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the next review date of multi_assets symbol\n        Returns\n        -------\n            Date of the next review of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Review is not scheduled\n        \"\"\"\npass\n@abstractmethod\ndef get_next_rebalance_date(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the next rebalance date of multi_assets symbol\n        Returns\n        -------\n            Date of the next rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not scheduled\n        \"\"\"\npass\n@abstractmethod\ndef get_next_rebalance_weight(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the next rebalance weight of multi_assets symbol\n        Returns\n        -------\n            Weight of the next rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not present in the payload\n        \"\"\"\npass\n@abstractmethod\ndef get_data_by_date(\nself, symbol: str, dates: Union[str, list]\n) -&gt; dict:  # pragma: no cover\n\"\"\"This function takes in a symbol and a date and returns a dictionary of the data for that date\n        This function is only for daily data.\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        date : str | list\n            The date of the data you want to get. format: YYYY-MM-DD\n        Returns\n        -------\n            A dictionary of the data\n        \"\"\"\npass\n@abstractmethod\ndef get_data_by_time(\nself, symbol: str, start: str, end: str = None, limit: int = 1000\n) -&gt; dict:  # pragma: no cover\n\"\"\"This function takes in a symbol and a start and end date and returns a dictionary of the data\n        for that period\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        start : str\n            The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n        end : str\n            The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n        Returns\n        -------\n            A dictionary of the data\n        \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.__init__","title":"<code>__init__(api_key, asset_type)</code>  <code>abstractmethod</code>","text":"<p>This function takes in an api_key and asset_type and sets them as attributes of the class</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.__init__--parameters","title":"Parameters","text":"str <p>Your API key.</p> str <p>The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.</p> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef __init__(self, api_key: str, asset_type: str):  # pragma: no cover\n\"\"\"This function takes in an api_key and asset_type and sets them as attributes of the class\n    Parameters\n    ----------\n    api_key : str\n        Your API key.\n    asset_type : str\n        The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_all_active_symbols","title":"<code>get_all_active_symbols(frequency=None, symbol_only=False)</code>  <code>abstractmethod</code>","text":"<p>This function returns a dictionary of all the active symbols</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_all_active_symbols--returns","title":"Returns","text":"<pre><code>A dictionary of all the active symbols\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_all_active_symbols(\nself, frequency: str = None, symbol_only: bool = False\n) -&gt; Union[list, dict]:  # pragma: no cover\n\"\"\"This function returns a dictionary of all the active symbols\n    Returns\n    -------\n        A dictionary of all the active symbols\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_contributions","title":"<code>get_contributions(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function returns the contributions of the single_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_contributions--returns","title":"Returns","text":"<pre><code>A dictionary of the contributions of the single_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_contributions(self, symbol: str) -&gt; dict:  # pragma: no cover\n\"\"\"This function returns the contributions of the single_assets symbol\n    Returns\n    -------\n        A dictionary of the contributions of the single_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_current_rebalance_weight","title":"<code>get_current_rebalance_weight(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function returns the current rebalance weight of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_current_rebalance_weight--returns","title":"Returns","text":"<pre><code>Weight of the current rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_current_rebalance_weight(self, symbol: str) -&gt; dict:  # pragma: no cover\n\"\"\"This function returns the current rebalance weight of multi_assets symbol\n    Returns\n    -------\n        Weight of the current rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_data_by_date","title":"<code>get_data_by_date(symbol, dates)</code>  <code>abstractmethod</code>","text":"<p>This function takes in a symbol and a date and returns a dictionary of the data for that date</p> <p>This function is only for daily data.</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_data_by_date--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> str | list <p>The date of the data you want to get. format: YYYY-MM-DD</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_data_by_date--returns","title":"Returns","text":"<pre><code>A dictionary of the data\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_data_by_date(\nself, symbol: str, dates: Union[str, list]\n) -&gt; dict:  # pragma: no cover\n\"\"\"This function takes in a symbol and a date and returns a dictionary of the data for that date\n    This function is only for daily data.\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    date : str | list\n        The date of the data you want to get. format: YYYY-MM-DD\n    Returns\n    -------\n        A dictionary of the data\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_data_by_time","title":"<code>get_data_by_time(symbol, start, end=None, limit=1000)</code>  <code>abstractmethod</code>","text":"<p>This function takes in a symbol and a start and end date and returns a dictionary of the data for that period</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_data_by_time--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> str <p>The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ</p> str <p>The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_data_by_time--returns","title":"Returns","text":"<pre><code>A dictionary of the data\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_data_by_time(\nself, symbol: str, start: str, end: str = None, limit: int = 1000\n) -&gt; dict:  # pragma: no cover\n\"\"\"This function takes in a symbol and a start and end date and returns a dictionary of the data\n    for that period\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    start : str\n        The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n    end : str\n        The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n    Returns\n    -------\n        A dictionary of the data\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_latest_data","title":"<code>get_latest_data(symbol, limit=1)</code>  <code>abstractmethod</code>","text":"<p>It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for that symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_latest_data--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> int <p>The number of data points to return.</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_latest_data--returns","title":"Returns","text":"<pre><code>A dictionary of the latest data for the symbol and limit.\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_latest_data(self, symbol: str, limit: int = 1) -&gt; dict:  # pragma: no cover\n\"\"\"It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for\n    that symbol\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    limit : int\n        The number of data points to return.\n    Returns\n    -------\n        A dictionary of the latest data for the symbol and limit.\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_latest_value","title":"<code>get_latest_value(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function takes in a symbol and returns the latest value for that symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_latest_value--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_latest_value--returns","title":"Returns","text":"<pre><code>The latest value for the symbol\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_latest_value(self, symbol: str) -&gt; float:  # pragma: no cover\n\"\"\"This function takes in a symbol and returns the latest value for that symbol\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    Returns\n    -------\n        The latest value for the symbol\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_next_rebalance_date","title":"<code>get_next_rebalance_date(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function returns the next rebalance date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_next_rebalance_date--returns","title":"Returns","text":"<pre><code>Date of the next rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_next_rebalance_date(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the next rebalance date of multi_assets symbol\n    Returns\n    -------\n        Date of the next rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not scheduled\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_next_rebalance_weight","title":"<code>get_next_rebalance_weight(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function returns the next rebalance weight of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_next_rebalance_weight--returns","title":"Returns","text":"<pre><code>Weight of the next rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not present in the payload\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_next_rebalance_weight(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the next rebalance weight of multi_assets symbol\n    Returns\n    -------\n        Weight of the next rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not present in the payload\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_next_review_date","title":"<code>get_next_review_date(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function returns the next review date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_next_review_date--returns","title":"Returns","text":"<pre><code>Date of the next review of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Review is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_next_review_date(self, symbol: str) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the next review date of multi_assets symbol\n    Returns\n    -------\n        Date of the next review of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Review is not scheduled\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_previous_rebalance_date","title":"<code>get_previous_rebalance_date(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function returns the previous rebalance date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_previous_rebalance_date--returns","title":"Returns","text":"<pre><code>Date of the previous rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_previous_rebalance_date(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the previous rebalance date of multi_assets symbol\n    Returns\n    -------\n        Date of the previous rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not scheduled\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_previous_review_date","title":"<code>get_previous_review_date(symbol)</code>  <code>abstractmethod</code>","text":"<p>This function returns the previous review date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_abc/#vinterunofficial.vinter_abc.VinterAPIABC.get_previous_review_date--returns","title":"Returns","text":"<pre><code>Date of the previous review of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Review is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_abc.py</code> <pre><code>@abstractmethod\ndef get_previous_review_date(\nself, symbol: str\n) -&gt; Union[str, None]:  # pragma: no cover\n\"\"\"This function returns the previous review date of multi_assets symbol\n    Returns\n    -------\n        Date of the previous review of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Review is not scheduled\n    \"\"\"\npass\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/","title":"vinter_sdk.py","text":""},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI","title":"<code>VinterAPI</code>","text":"<p>             Bases: <code>VinterAPIABC</code></p> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>class VinterAPI(VinterAPIABC):\ndef __init__(self, api_key: str, asset_type: str):\n\"\"\"This function takes in an api_key and asset_type and sets them as attributes of the class\n        Parameters\n        ----------\n        api_key : str\n            Your API key.\n        asset_type : str\n            The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.\n        \"\"\"\nself.api_key = api_key\nself.asset_type = asset_type\nself.frequencies = [frequency.value for frequency in Frequency]\nself.valid_asset_types = [asset_type.value for asset_type in AssetType]\nVinterValidation.validate_asset_type(self.asset_type)\nself.httpx_client = httpx.Client(follow_redirects=True, timeout=10)\ndef get_all_active_symbols(\nself, frequency: str = None, symbol_only: bool = False\n) -&gt; Union[list, dict]:\n\"\"\"This function returns a dictionary of all the active symbols\n        Returns\n        -------\n            A dictionary of all the active symbols\n        \"\"\"\nurl = VinterUrl.get_active_url(self.asset_type)\nheaders = {}\nresponse = self.httpx_client.get(url, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request failed\ndata = response.json()[\"data\"]\nif frequency is not None:\nVinterValidation.validate_frequency(frequency)\ndata = [\nasset for asset in data if asset[\"symbol\"].split(\"-\")[-1] == frequency\n]\nif symbol_only:\ndata = [asset[\"symbol\"] for asset in data]\nreturn data\ndef get_latest_data(self, symbol: str, limit: int = 1) -&gt; dict:\n\"\"\"It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for\n        that symbol\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        limit : int\n            The number of data points to return.\n        Returns\n        -------\n            A dictionary of the latest data for the symbol and limit.\n        \"\"\"\nurl = VinterUrl.get_url_by_symbol(self.asset_type, symbol)\nparams = {\"symbol\": symbol, \"limit\": limit}\nheaders = {\"Authorization\": self.api_key}\nresponse = self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn data\ndef get_latest_value(self, symbol: str) -&gt; float:\n\"\"\"This function takes in a symbol and returns the latest value for that symbol\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            The latest value for the symbol\n        \"\"\"\ndata = self.get_latest_data(symbol=symbol)\nreturn data[0][\"value\"]\ndef _filter_by_symbol(self, data: list, symbol: str) -&gt; list:\n\"\"\"This function takes in a list of data and a symbol and returns a list of data for that symbol\n        Parameters\n        ----------\n        data : list\n            A list of data\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            A list of data for the symbol\n        \"\"\"\nreturn [asset for asset in data if asset[\"symbol\"] == symbol]\ndef _get_active_asset_data(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the data for the active asset\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            A dictionary of the data for the active asset\n        \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\ndata = self.get_all_active_symbols()\noutput = self._filter_by_symbol(data=data, symbol=symbol)\nif len(output) == 0:\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn output[0]\ndef get_current_rebalance_weight(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the current rebalance weight of multi_assets symbol\n        Returns\n        -------\n            Weight of the current rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"weights\", None)\nif output is None or output == \"\":\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn output\ndef get_contributions(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the contributions of the single_assets symbol\n        Returns\n        -------\n            A dictionary of the contributions of the single_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n        \"\"\"\nif self.asset_type != AssetType.SINGLE_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.SINGLE_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"contrib\", None)\nif output == \"\" or output is None:\nraise ValueError(\nf\"The symbol {symbol} does not have any contributions associated with it.\"\n)\nreturn output\ndef get_previous_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous rebalance date of multi_assets symbol\n        Returns\n        -------\n            Date of the previous rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_rebalance_date\", None)\nreturn output\ndef get_previous_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous review date of multi_assets symbol\n        Returns\n        -------\n            Date of the previous review of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Review is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_review_date\", None)\nreturn output\ndef get_next_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next review date of multi_assets symbol\n        Returns\n        -------\n            Date of the next review of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Review is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_review_date\", None)\nreturn output\ndef get_next_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance date of multi_assets symbol\n        Returns\n        -------\n            Date of the next rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_date\", None)\nreturn output\ndef get_next_rebalance_weight(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance weight of multi_assets symbol\n        Returns\n        -------\n            Weight of the next rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not present in the payload\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_weights\", None)\nreturn output\ndef get_data_by_date(self, symbol: str, dates: Union[str, list]) -&gt; dict:\n\"\"\"This function takes in a symbol and a date and returns a dictionary of the data for that date\n        This function is only for daily data.\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        date : str | list\n            The date of the data you want to get. format: YYYY-MM-DD\n        Returns\n        -------\n            A dictionary of the data\n        \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nif frequency != Frequency.DAILY.value:\nraise ValueError(\"The frequency must be daily to use this function.\")\nif isinstance(dates, str):\ndates = [dates]\n# Validate Dates with regex pattern &amp; Date validation\nVinterValidation.validate_dates(dates)\nstart_date, last_date = dates[0], dates[-1]\n# Adding 1 day to the last date to get the data for the last date\nlast_date = datetime.strptime(last_date, \"%Y-%m-%d\") + timedelta(days=1)\n# Converting the datetime object to string\nlast_date = last_date.strftime(\"%Y-%m-%d\")\ndata = self.get_data_by_time(symbol=symbol, start=start_date, end=last_date)\nreturn data\ndef get_data_by_time(\nself, symbol: str, start: str, end: str = None, limit: int = 1000\n) -&gt; dict:\n\"\"\"This function takes in a symbol and a start and end date and returns a dictionary of the data\n        for that period\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        start : str\n            The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n        end : str\n            The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n        Returns\n        -------\n            A dictionary of the data\n        \"\"\"\nurl = VinterUrl.get_url_by_symbol(asset_type=self.asset_type, symbol=symbol)\nparams = {\n\"symbol\": symbol,\n\"start_time\": start,\n\"end_time\": end,\n\"limit\": limit,\n}\nheaders = {\"Authorization\": self.api_key}\nresponse = self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request fails\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\nf\"No data was found for the symbol: {symbol} between {start} and {end}.\"\n)\nreturn data\ndef save_data_to_file(\nself, data: dict, filename: str, file_type: str = \"csv\", seprator: str = \",\"\n) -&gt; None:  # pragma: no cover\n\"\"\"This function takes in a dictionary of data and a filename and saves the data to a csv file\n        Parameters\n        ----------\n        data : dict\n            A dictionary of data to save to a csv file.\n        filename : str\n            The name of the file to save the data to.\n        file_type : str\n            The type of file to save the data to. This can be one of the following:\n            [\"csv\", \"json\"]\n        seprator : str\n            The seprator to use when saving the data to the csv file.\n        \"\"\"\nfile_type = file_type.lower()\nif file_type not in [\"csv\", \"json\"]:\nraise ValueError(\"The file type must be either csv or json\")\nif file_type == \"json\":\nwith open(filename, \"w\") as f:\njson.dump(data, f, indent=4)\nreturn\nelif file_type == \"csv\":\nwith open(filename, \"a\") as f:\ncsv.DictWriter(\nf, data[0].keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writeheader()  # write the header\nfor row in data:\n# Make Sure dict and list are converted to JSON string\nfor key, value in row.items():\nif isinstance(value, (dict, list)):\nrow[key] = json.dumps(value)\ncsv.DictWriter(\nf, row.keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writerow(row)\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.__init__","title":"<code>__init__(api_key, asset_type)</code>","text":"<p>This function takes in an api_key and asset_type and sets them as attributes of the class</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.__init__--parameters","title":"Parameters","text":"str <p>Your API key.</p> str <p>The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.</p> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def __init__(self, api_key: str, asset_type: str):\n\"\"\"This function takes in an api_key and asset_type and sets them as attributes of the class\n    Parameters\n    ----------\n    api_key : str\n        Your API key.\n    asset_type : str\n        The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.\n    \"\"\"\nself.api_key = api_key\nself.asset_type = asset_type\nself.frequencies = [frequency.value for frequency in Frequency]\nself.valid_asset_types = [asset_type.value for asset_type in AssetType]\nVinterValidation.validate_asset_type(self.asset_type)\nself.httpx_client = httpx.Client(follow_redirects=True, timeout=10)\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_all_active_symbols","title":"<code>get_all_active_symbols(frequency=None, symbol_only=False)</code>","text":"<p>This function returns a dictionary of all the active symbols</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_all_active_symbols--returns","title":"Returns","text":"<pre><code>A dictionary of all the active symbols\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_all_active_symbols(\nself, frequency: str = None, symbol_only: bool = False\n) -&gt; Union[list, dict]:\n\"\"\"This function returns a dictionary of all the active symbols\n    Returns\n    -------\n        A dictionary of all the active symbols\n    \"\"\"\nurl = VinterUrl.get_active_url(self.asset_type)\nheaders = {}\nresponse = self.httpx_client.get(url, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request failed\ndata = response.json()[\"data\"]\nif frequency is not None:\nVinterValidation.validate_frequency(frequency)\ndata = [\nasset for asset in data if asset[\"symbol\"].split(\"-\")[-1] == frequency\n]\nif symbol_only:\ndata = [asset[\"symbol\"] for asset in data]\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_contributions","title":"<code>get_contributions(symbol)</code>","text":"<p>This function returns the contributions of the single_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_contributions--returns","title":"Returns","text":"<pre><code>A dictionary of the contributions of the single_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_contributions(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the contributions of the single_assets symbol\n    Returns\n    -------\n        A dictionary of the contributions of the single_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n    \"\"\"\nif self.asset_type != AssetType.SINGLE_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.SINGLE_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"contrib\", None)\nif output == \"\" or output is None:\nraise ValueError(\nf\"The symbol {symbol} does not have any contributions associated with it.\"\n)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_current_rebalance_weight","title":"<code>get_current_rebalance_weight(symbol)</code>","text":"<p>This function returns the current rebalance weight of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_current_rebalance_weight--returns","title":"Returns","text":"<pre><code>Weight of the current rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_current_rebalance_weight(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the current rebalance weight of multi_assets symbol\n    Returns\n    -------\n        Weight of the current rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"weights\", None)\nif output is None or output == \"\":\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_data_by_date","title":"<code>get_data_by_date(symbol, dates)</code>","text":"<p>This function takes in a symbol and a date and returns a dictionary of the data for that date</p> <p>This function is only for daily data.</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_data_by_date--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> str | list <p>The date of the data you want to get. format: YYYY-MM-DD</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_data_by_date--returns","title":"Returns","text":"<pre><code>A dictionary of the data\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_data_by_date(self, symbol: str, dates: Union[str, list]) -&gt; dict:\n\"\"\"This function takes in a symbol and a date and returns a dictionary of the data for that date\n    This function is only for daily data.\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    date : str | list\n        The date of the data you want to get. format: YYYY-MM-DD\n    Returns\n    -------\n        A dictionary of the data\n    \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nif frequency != Frequency.DAILY.value:\nraise ValueError(\"The frequency must be daily to use this function.\")\nif isinstance(dates, str):\ndates = [dates]\n# Validate Dates with regex pattern &amp; Date validation\nVinterValidation.validate_dates(dates)\nstart_date, last_date = dates[0], dates[-1]\n# Adding 1 day to the last date to get the data for the last date\nlast_date = datetime.strptime(last_date, \"%Y-%m-%d\") + timedelta(days=1)\n# Converting the datetime object to string\nlast_date = last_date.strftime(\"%Y-%m-%d\")\ndata = self.get_data_by_time(symbol=symbol, start=start_date, end=last_date)\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_data_by_time","title":"<code>get_data_by_time(symbol, start, end=None, limit=1000)</code>","text":"<p>This function takes in a symbol and a start and end date and returns a dictionary of the data for that period</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_data_by_time--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> str <p>The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ</p> str <p>The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_data_by_time--returns","title":"Returns","text":"<pre><code>A dictionary of the data\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_data_by_time(\nself, symbol: str, start: str, end: str = None, limit: int = 1000\n) -&gt; dict:\n\"\"\"This function takes in a symbol and a start and end date and returns a dictionary of the data\n    for that period\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    start : str\n        The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n    end : str\n        The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n    Returns\n    -------\n        A dictionary of the data\n    \"\"\"\nurl = VinterUrl.get_url_by_symbol(asset_type=self.asset_type, symbol=symbol)\nparams = {\n\"symbol\": symbol,\n\"start_time\": start,\n\"end_time\": end,\n\"limit\": limit,\n}\nheaders = {\"Authorization\": self.api_key}\nresponse = self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request fails\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\nf\"No data was found for the symbol: {symbol} between {start} and {end}.\"\n)\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_latest_data","title":"<code>get_latest_data(symbol, limit=1)</code>","text":"<p>It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for that symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_latest_data--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> int <p>The number of data points to return.</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_latest_data--returns","title":"Returns","text":"<pre><code>A dictionary of the latest data for the symbol and limit.\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_latest_data(self, symbol: str, limit: int = 1) -&gt; dict:\n\"\"\"It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for\n    that symbol\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    limit : int\n        The number of data points to return.\n    Returns\n    -------\n        A dictionary of the latest data for the symbol and limit.\n    \"\"\"\nurl = VinterUrl.get_url_by_symbol(self.asset_type, symbol)\nparams = {\"symbol\": symbol, \"limit\": limit}\nheaders = {\"Authorization\": self.api_key}\nresponse = self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_latest_value","title":"<code>get_latest_value(symbol)</code>","text":"<p>This function takes in a symbol and returns the latest value for that symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_latest_value--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_latest_value--returns","title":"Returns","text":"<pre><code>The latest value for the symbol\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_latest_value(self, symbol: str) -&gt; float:\n\"\"\"This function takes in a symbol and returns the latest value for that symbol\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    Returns\n    -------\n        The latest value for the symbol\n    \"\"\"\ndata = self.get_latest_data(symbol=symbol)\nreturn data[0][\"value\"]\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_next_rebalance_date","title":"<code>get_next_rebalance_date(symbol)</code>","text":"<p>This function returns the next rebalance date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_next_rebalance_date--returns","title":"Returns","text":"<pre><code>Date of the next rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_next_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance date of multi_assets symbol\n    Returns\n    -------\n        Date of the next rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_next_rebalance_weight","title":"<code>get_next_rebalance_weight(symbol)</code>","text":"<p>This function returns the next rebalance weight of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_next_rebalance_weight--returns","title":"Returns","text":"<pre><code>Weight of the next rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not present in the payload\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_next_rebalance_weight(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance weight of multi_assets symbol\n    Returns\n    -------\n        Weight of the next rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not present in the payload\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_weights\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_next_review_date","title":"<code>get_next_review_date(symbol)</code>","text":"<p>This function returns the next review date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_next_review_date--returns","title":"Returns","text":"<pre><code>Date of the next review of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Review is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_next_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next review date of multi_assets symbol\n    Returns\n    -------\n        Date of the next review of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Review is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_review_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_previous_rebalance_date","title":"<code>get_previous_rebalance_date(symbol)</code>","text":"<p>This function returns the previous rebalance date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_previous_rebalance_date--returns","title":"Returns","text":"<pre><code>Date of the previous rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_previous_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous rebalance date of multi_assets symbol\n    Returns\n    -------\n        Date of the previous rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_rebalance_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_previous_review_date","title":"<code>get_previous_review_date(symbol)</code>","text":"<p>This function returns the previous review date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.get_previous_review_date--returns","title":"Returns","text":"<pre><code>Date of the previous review of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Review is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def get_previous_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous review date of multi_assets symbol\n    Returns\n    -------\n        Date of the previous review of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Review is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_review_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.save_data_to_file","title":"<code>save_data_to_file(data, filename, file_type='csv', seprator=',')</code>","text":"<p>This function takes in a dictionary of data and a filename and saves the data to a csv file</p>"},{"location":"vinterunofficial_doc/vinter_sdk/#vinterunofficial.vinter_sdk.VinterAPI.save_data_to_file--parameters","title":"Parameters","text":"dict <p>A dictionary of data to save to a csv file.</p> str <p>The name of the file to save the data to.</p> str <p>The type of file to save the data to. This can be one of the following: [\"csv\", \"json\"]</p> str <p>The seprator to use when saving the data to the csv file.</p> Source code in <code>vinterunofficial/vinter_sdk.py</code> <pre><code>def save_data_to_file(\nself, data: dict, filename: str, file_type: str = \"csv\", seprator: str = \",\"\n) -&gt; None:  # pragma: no cover\n\"\"\"This function takes in a dictionary of data and a filename and saves the data to a csv file\n    Parameters\n    ----------\n    data : dict\n        A dictionary of data to save to a csv file.\n    filename : str\n        The name of the file to save the data to.\n    file_type : str\n        The type of file to save the data to. This can be one of the following:\n        [\"csv\", \"json\"]\n    seprator : str\n        The seprator to use when saving the data to the csv file.\n    \"\"\"\nfile_type = file_type.lower()\nif file_type not in [\"csv\", \"json\"]:\nraise ValueError(\"The file type must be either csv or json\")\nif file_type == \"json\":\nwith open(filename, \"w\") as f:\njson.dump(data, f, indent=4)\nreturn\nelif file_type == \"csv\":\nwith open(filename, \"a\") as f:\ncsv.DictWriter(\nf, data[0].keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writeheader()  # write the header\nfor row in data:\n# Make Sure dict and list are converted to JSON string\nfor key, value in row.items():\nif isinstance(value, (dict, list)):\nrow[key] = json.dumps(value)\ncsv.DictWriter(\nf, row.keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writerow(row)\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/","title":"vinter_sdk_async.py","text":""},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync","title":"<code>VinterAPIAsync</code>","text":"<p>             Bases: <code>VinterAPIABC</code></p> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>class VinterAPIAsync(VinterAPIABC):\ndef __init__(self, api_key: str, asset_type: str):\n\"\"\"This function takes in an api_key and asset_type and sets them as attributes of the class\n        Parameters\n        ----------\n        api_key : str\n            Your API key.\n        asset_type : str\n            The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.\n        \"\"\"\nself.api_key = api_key\nself.asset_type = asset_type\nself.frequencies = [frequency.value for frequency in Frequency]\nself.valid_asset_types = [asset_type.value for asset_type in AssetType]\nVinterValidation.validate_asset_type(self.asset_type)\nself.httpx_client = httpx.AsyncClient(follow_redirects=True, timeout=10)\nasync def get_all_active_symbols(\nself, frequency: str = None, symbol_only: bool = False\n) -&gt; Union[list, dict]:\n\"\"\"This function returns a dictionary of all the active symbols\n        Returns\n        -------\n            A dictionary of all the active symbols\n        \"\"\"\nurl = VinterUrl.get_active_url(self.asset_type)\nheaders = {}\nresponse = await self.httpx_client.get(url, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request failed\ndata = response.json()[\"data\"]\nif frequency is not None:\nVinterValidation.validate_frequency(frequency)\ndata = [\nasset for asset in data if asset[\"symbol\"].split(\"-\")[-1] == frequency\n]\nif symbol_only:\ndata = [asset[\"symbol\"] for asset in data]\nreturn data\nasync def get_latest_data(self, symbol: str, limit: int = 1) -&gt; dict:\n\"\"\"It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for\n        that symbol\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        limit : int\n            The number of data points to return.\n        Returns\n        -------\n            A dictionary of the latest data for the symbol and limit.\n        \"\"\"\nurl = VinterUrl.get_url_by_symbol(self.asset_type, symbol)\nparams = {\"symbol\": symbol, \"limit\": limit}\nheaders = {\"Authorization\": self.api_key}\nresponse = await self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn data\nasync def get_latest_value(self, symbol: str) -&gt; float:\n\"\"\"This function takes in a symbol and returns the latest value for that symbol\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            The latest value for the symbol\n        \"\"\"\ndata = await self.get_latest_data(symbol=symbol)\nreturn data[0][\"value\"]\ndef _filter_by_symbol(self, data: list, symbol: str) -&gt; list:\n\"\"\"This function takes in a list of data and a symbol and returns a list of data for that symbol\n        Parameters\n        ----------\n        data : list\n            A list of data\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            A list of data for the symbol\n        \"\"\"\nreturn [asset for asset in data if asset[\"symbol\"] == symbol]\nasync def _get_active_asset_data(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the data for the active asset\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        Returns\n        -------\n            A dictionary of the data for the active asset\n        \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\ndata = await self.get_all_active_symbols()\noutput = self._filter_by_symbol(data=data, symbol=symbol)\nif len(output) == 0:\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn output[0]\nasync def get_current_rebalance_weight(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the current rebalance weight of multi_assets symbol\n        Returns\n        -------\n            Weight of the current rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"weights\", None)\nif output is None or output == \"\":\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn output\nasync def get_contributions(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the contributions of the single_assets symbol\n        Returns\n        -------\n            A dictionary of the contributions of the single_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n        \"\"\"\nif self.asset_type != AssetType.SINGLE_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.SINGLE_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"contrib\", None)\nif output == \"\" or output is None:\nraise ValueError(\nf\"The symbol {symbol} does not have any contributions associated with it.\"\n)\nreturn output\nasync def get_previous_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous rebalance date of multi_assets symbol\n        Returns\n        -------\n            Date of the previous rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_rebalance_date\", None)\nreturn output\nasync def get_previous_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous review date of multi_assets symbol\n        Returns\n        -------\n            Date of the previous review of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Review is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_review_date\", None)\nreturn output\nasync def get_next_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next review date of multi_assets symbol\n        Returns\n        -------\n            Date of the next review of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Review is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_review_date\", None)\nreturn output\nasync def get_next_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance date of multi_assets symbol\n        Returns\n        -------\n            Date of the next rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not scheduled\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_date\", None)\nreturn output\nasync def get_next_rebalance_weight(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance weight of multi_assets symbol\n        Returns\n        -------\n            Weight of the next rebalance of the multi_assets symbol\n            OR\n            ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n            OR\n            None if the symbol Rebalance is not present in the payload\n        \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_weights\", None)\nreturn output\nasync def get_data_by_date(self, symbol: str, dates: Union[str, list]) -&gt; dict:\n\"\"\"This function takes in a symbol and a date and returns a dictionary of the data for that date\n        This function is only for daily data.\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        date : str | list\n            The date of the data you want to get. format: YYYY-MM-DD\n        Returns\n        -------\n            A dictionary of the data\n        \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nif frequency != Frequency.DAILY.value:\nraise ValueError(\"The frequency must be daily to use this function.\")\nif isinstance(dates, str):\ndates = [dates]\n# Validate Dates with regex pattern &amp; Date validation\nVinterValidation.validate_dates(dates)\nstart_date, last_date = dates[0], dates[-1]\n# Adding 1 day to the last date to get the data for the last date\nlast_date = datetime.strptime(last_date, \"%Y-%m-%d\") + timedelta(days=1)\n# Converting the datetime object to string\nlast_date = last_date.strftime(\"%Y-%m-%d\")\ndata = await self.get_data_by_time(\nsymbol=symbol, start=start_date, end=last_date\n)\nreturn data\nasync def get_data_by_time(\nself, symbol: str, start: str, end: str = None, limit: int = 1000\n) -&gt; dict:\n\"\"\"This function takes in a symbol and a start and end date and returns a dictionary of the data\n        for that period\n        Parameters\n        ----------\n        symbol : str\n            The symbol of the asset you want to get data for.\n        start : str\n            The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n        end : str\n            The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n        Returns\n        -------\n            A dictionary of the data\n        \"\"\"\nurl = VinterUrl.get_url_by_symbol(asset_type=self.asset_type, symbol=symbol)\nparams = {\n\"symbol\": symbol,\n\"start_time\": start,\n\"end_time\": end,\n\"limit\": limit,\n}\nheaders = {\"Authorization\": self.api_key}\nresponse = await self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request fails\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\nf\"No data was found for the symbol: {symbol} between {start} and {end}.\"\n)\nreturn data\ndef save_data_to_file(\nself, data: dict, filename: str, file_type: str = \"csv\", seprator: str = \",\"\n) -&gt; None:  # pragma: no cover\n\"\"\"This function takes in a dictionary of data and a filename and saves the data to a csv file\n        Parameters\n        ----------\n        data : dict\n            A dictionary of data to save to a csv file.\n        filename : str\n            The name of the file to save the data to.\n        file_type : str\n            The type of file to save the data to. This can be one of the following:\n            [\"csv\", \"json\"]\n        seprator : str\n            The seprator to use when saving the data to the csv file.\n        \"\"\"\nfile_type = file_type.lower()\nif file_type not in [\"csv\", \"json\"]:\nraise ValueError(\"The file type must be either csv or json\")\nif file_type == \"json\":\nwith open(filename, \"w\") as f:\njson.dump(data, f, indent=4)\nreturn\nelif file_type == \"csv\":\nwith open(filename, \"a\") as f:\ncsv.DictWriter(\nf, data[0].keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writeheader()  # write the header\nfor row in data:\n# Make Sure dict and list are converted to JSON string\nfor key, value in row.items():\nif isinstance(value, (dict, list)):\nrow[key] = json.dumps(value)\ncsv.DictWriter(\nf, row.keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writerow(row)\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.__init__","title":"<code>__init__(api_key, asset_type)</code>","text":"<p>This function takes in an api_key and asset_type and sets them as attributes of the class</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.__init__--parameters","title":"Parameters","text":"str <p>Your API key.</p> str <p>The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.</p> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>def __init__(self, api_key: str, asset_type: str):\n\"\"\"This function takes in an api_key and asset_type and sets them as attributes of the class\n    Parameters\n    ----------\n    api_key : str\n        Your API key.\n    asset_type : str\n        The type of asset you want to get data for. The acceptable asset types listed in the AssetType enum.\n    \"\"\"\nself.api_key = api_key\nself.asset_type = asset_type\nself.frequencies = [frequency.value for frequency in Frequency]\nself.valid_asset_types = [asset_type.value for asset_type in AssetType]\nVinterValidation.validate_asset_type(self.asset_type)\nself.httpx_client = httpx.AsyncClient(follow_redirects=True, timeout=10)\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_all_active_symbols","title":"<code>get_all_active_symbols(frequency=None, symbol_only=False)</code>  <code>async</code>","text":"<p>This function returns a dictionary of all the active symbols</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_all_active_symbols--returns","title":"Returns","text":"<pre><code>A dictionary of all the active symbols\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_all_active_symbols(\nself, frequency: str = None, symbol_only: bool = False\n) -&gt; Union[list, dict]:\n\"\"\"This function returns a dictionary of all the active symbols\n    Returns\n    -------\n        A dictionary of all the active symbols\n    \"\"\"\nurl = VinterUrl.get_active_url(self.asset_type)\nheaders = {}\nresponse = await self.httpx_client.get(url, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request failed\ndata = response.json()[\"data\"]\nif frequency is not None:\nVinterValidation.validate_frequency(frequency)\ndata = [\nasset for asset in data if asset[\"symbol\"].split(\"-\")[-1] == frequency\n]\nif symbol_only:\ndata = [asset[\"symbol\"] for asset in data]\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_contributions","title":"<code>get_contributions(symbol)</code>  <code>async</code>","text":"<p>This function returns the contributions of the single_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_contributions--returns","title":"Returns","text":"<pre><code>A dictionary of the contributions of the single_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_contributions(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the contributions of the single_assets symbol\n    Returns\n    -------\n        A dictionary of the contributions of the single_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type single_assets\n    \"\"\"\nif self.asset_type != AssetType.SINGLE_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.SINGLE_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"contrib\", None)\nif output == \"\" or output is None:\nraise ValueError(\nf\"The symbol {symbol} does not have any contributions associated with it.\"\n)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_current_rebalance_weight","title":"<code>get_current_rebalance_weight(symbol)</code>  <code>async</code>","text":"<p>This function returns the current rebalance weight of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_current_rebalance_weight--returns","title":"Returns","text":"<pre><code>Weight of the current rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_current_rebalance_weight(self, symbol: str) -&gt; dict:\n\"\"\"This function returns the current rebalance weight of multi_assets symbol\n    Returns\n    -------\n        Weight of the current rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"weights\", None)\nif output is None or output == \"\":\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_data_by_date","title":"<code>get_data_by_date(symbol, dates)</code>  <code>async</code>","text":"<p>This function takes in a symbol and a date and returns a dictionary of the data for that date</p> <p>This function is only for daily data.</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_data_by_date--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> str | list <p>The date of the data you want to get. format: YYYY-MM-DD</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_data_by_date--returns","title":"Returns","text":"<pre><code>A dictionary of the data\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_data_by_date(self, symbol: str, dates: Union[str, list]) -&gt; dict:\n\"\"\"This function takes in a symbol and a date and returns a dictionary of the data for that date\n    This function is only for daily data.\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    date : str | list\n        The date of the data you want to get. format: YYYY-MM-DD\n    Returns\n    -------\n        A dictionary of the data\n    \"\"\"\nsymbol, frequency = VinterValidation.validate_symbol_frequency(symbol)\nif frequency != Frequency.DAILY.value:\nraise ValueError(\"The frequency must be daily to use this function.\")\nif isinstance(dates, str):\ndates = [dates]\n# Validate Dates with regex pattern &amp; Date validation\nVinterValidation.validate_dates(dates)\nstart_date, last_date = dates[0], dates[-1]\n# Adding 1 day to the last date to get the data for the last date\nlast_date = datetime.strptime(last_date, \"%Y-%m-%d\") + timedelta(days=1)\n# Converting the datetime object to string\nlast_date = last_date.strftime(\"%Y-%m-%d\")\ndata = await self.get_data_by_time(\nsymbol=symbol, start=start_date, end=last_date\n)\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_data_by_time","title":"<code>get_data_by_time(symbol, start, end=None, limit=1000)</code>  <code>async</code>","text":"<p>This function takes in a symbol and a start and end date and returns a dictionary of the data for that period</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_data_by_time--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> str <p>The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ</p> str <p>The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_data_by_time--returns","title":"Returns","text":"<pre><code>A dictionary of the data\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_data_by_time(\nself, symbol: str, start: str, end: str = None, limit: int = 1000\n) -&gt; dict:\n\"\"\"This function takes in a symbol and a start and end date and returns a dictionary of the data\n    for that period\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    start : str\n        The start datatime . format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n    end : str\n        The end datatime. format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS.sssZ\n    Returns\n    -------\n        A dictionary of the data\n    \"\"\"\nurl = VinterUrl.get_url_by_symbol(asset_type=self.asset_type, symbol=symbol)\nparams = {\n\"symbol\": symbol,\n\"start_time\": start,\n\"end_time\": end,\n\"limit\": limit,\n}\nheaders = {\"Authorization\": self.api_key}\nresponse = await self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()  # Raise an exception if the request fails\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\nf\"No data was found for the symbol: {symbol} between {start} and {end}.\"\n)\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_latest_data","title":"<code>get_latest_data(symbol, limit=1)</code>  <code>async</code>","text":"<p>It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for that symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_latest_data--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p> int <p>The number of data points to return.</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_latest_data--returns","title":"Returns","text":"<pre><code>A dictionary of the latest data for the symbol and limit.\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_latest_data(self, symbol: str, limit: int = 1) -&gt; dict:\n\"\"\"It takes a symbol and a limit as parameters, and returns a dictionary of the latest data for\n    that symbol\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    limit : int\n        The number of data points to return.\n    Returns\n    -------\n        A dictionary of the latest data for the symbol and limit.\n    \"\"\"\nurl = VinterUrl.get_url_by_symbol(self.asset_type, symbol)\nparams = {\"symbol\": symbol, \"limit\": limit}\nheaders = {\"Authorization\": self.api_key}\nresponse = await self.httpx_client.get(url, params=params, headers=headers)\nresponse.raise_for_status()\ndata = response.json()[\"data\"]\nif len(data) == 0:\nraise ValueError(\"No data was found for the symbol: {}\".format(symbol))\nreturn data\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_latest_value","title":"<code>get_latest_value(symbol)</code>  <code>async</code>","text":"<p>This function takes in a symbol and returns the latest value for that symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_latest_value--parameters","title":"Parameters","text":"str <p>The symbol of the asset you want to get data for.</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_latest_value--returns","title":"Returns","text":"<pre><code>The latest value for the symbol\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_latest_value(self, symbol: str) -&gt; float:\n\"\"\"This function takes in a symbol and returns the latest value for that symbol\n    Parameters\n    ----------\n    symbol : str\n        The symbol of the asset you want to get data for.\n    Returns\n    -------\n        The latest value for the symbol\n    \"\"\"\ndata = await self.get_latest_data(symbol=symbol)\nreturn data[0][\"value\"]\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_next_rebalance_date","title":"<code>get_next_rebalance_date(symbol)</code>  <code>async</code>","text":"<p>This function returns the next rebalance date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_next_rebalance_date--returns","title":"Returns","text":"<pre><code>Date of the next rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_next_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance date of multi_assets symbol\n    Returns\n    -------\n        Date of the next rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_next_rebalance_weight","title":"<code>get_next_rebalance_weight(symbol)</code>  <code>async</code>","text":"<p>This function returns the next rebalance weight of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_next_rebalance_weight--returns","title":"Returns","text":"<pre><code>Weight of the next rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not present in the payload\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_next_rebalance_weight(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next rebalance weight of multi_assets symbol\n    Returns\n    -------\n        Weight of the next rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not present in the payload\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_rebalance_weights\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_next_review_date","title":"<code>get_next_review_date(symbol)</code>  <code>async</code>","text":"<p>This function returns the next review date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_next_review_date--returns","title":"Returns","text":"<pre><code>Date of the next review of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Review is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_next_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the next review date of multi_assets symbol\n    Returns\n    -------\n        Date of the next review of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Review is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"next_review_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_previous_rebalance_date","title":"<code>get_previous_rebalance_date(symbol)</code>  <code>async</code>","text":"<p>This function returns the previous rebalance date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_previous_rebalance_date--returns","title":"Returns","text":"<pre><code>Date of the previous rebalance of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Rebalance is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_previous_rebalance_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous rebalance date of multi_assets symbol\n    Returns\n    -------\n        Date of the previous rebalance of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Rebalance is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_rebalance_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_previous_review_date","title":"<code>get_previous_review_date(symbol)</code>  <code>async</code>","text":"<p>This function returns the previous review date of multi_assets symbol</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.get_previous_review_date--returns","title":"Returns","text":"<pre><code>Date of the previous review of the multi_assets symbol\n\nOR\n\nValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n\nOR\n\nNone if the symbol Review is not scheduled\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>async def get_previous_review_date(self, symbol: str) -&gt; Union[str, None]:\n\"\"\"This function returns the previous review date of multi_assets symbol\n    Returns\n    -------\n        Date of the previous review of the multi_assets symbol\n        OR\n        ValueError if the symbol is not a present in the list of active symbols for asset_type multi_assets\n        OR\n        None if the symbol Review is not scheduled\n    \"\"\"\nif self.asset_type != AssetType.MULTI_ASSET.value:\nraise ValueError(\nf\"The asset type must be {AssetType.MULTI_ASSET.value} to use this function\"\n)\noutput = \"\"\ndata = await self._get_active_asset_data(symbol=symbol)\noutput = data.get(\"previous_review_date\", None)\nreturn output\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.save_data_to_file","title":"<code>save_data_to_file(data, filename, file_type='csv', seprator=',')</code>","text":"<p>This function takes in a dictionary of data and a filename and saves the data to a csv file</p>"},{"location":"vinterunofficial_doc/vinter_sdk_async/#vinterunofficial.vinter_sdk_async.VinterAPIAsync.save_data_to_file--parameters","title":"Parameters","text":"dict <p>A dictionary of data to save to a csv file.</p> str <p>The name of the file to save the data to.</p> str <p>The type of file to save the data to. This can be one of the following: [\"csv\", \"json\"]</p> str <p>The seprator to use when saving the data to the csv file.</p> Source code in <code>vinterunofficial/vinter_sdk_async.py</code> <pre><code>def save_data_to_file(\nself, data: dict, filename: str, file_type: str = \"csv\", seprator: str = \",\"\n) -&gt; None:  # pragma: no cover\n\"\"\"This function takes in a dictionary of data and a filename and saves the data to a csv file\n    Parameters\n    ----------\n    data : dict\n        A dictionary of data to save to a csv file.\n    filename : str\n        The name of the file to save the data to.\n    file_type : str\n        The type of file to save the data to. This can be one of the following:\n        [\"csv\", \"json\"]\n    seprator : str\n        The seprator to use when saving the data to the csv file.\n    \"\"\"\nfile_type = file_type.lower()\nif file_type not in [\"csv\", \"json\"]:\nraise ValueError(\"The file type must be either csv or json\")\nif file_type == \"json\":\nwith open(filename, \"w\") as f:\njson.dump(data, f, indent=4)\nreturn\nelif file_type == \"csv\":\nwith open(filename, \"a\") as f:\ncsv.DictWriter(\nf, data[0].keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writeheader()  # write the header\nfor row in data:\n# Make Sure dict and list are converted to JSON string\nfor key, value in row.items():\nif isinstance(value, (dict, list)):\nrow[key] = json.dumps(value)\ncsv.DictWriter(\nf, row.keys(), delimiter=seprator, lineterminator=\"\\n\"\n).writerow(row)\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_ws/","title":"vinter_sdk_ws.py","text":""},{"location":"vinterunofficial_doc/vinter_sdk_ws/#vinterunofficial.vinter_sdk_ws.VinterAPIWS","title":"<code>VinterAPIWS</code>","text":"Source code in <code>vinterunofficial/vinter_sdk_ws.py</code> <pre><code>class VinterAPIWS:\ndef __init__(\nself, symbol, token, asset_type, on_message, on_error, on_close, on_open\n):\n\"\"\"The function takes in a symbol, token, asset type, and four callback functions. It then creates\n        a websocket connection to the url for the symbol and asset type.\n        Parameters\n        ----------\n        symbol\n            The symbol you want to subscribe to.\n        token\n            Your API token.\n        asset_type\n            The asset type of the symbol.\n        on_message\n            This is the callback function that will be called when a message is received from the server.\n        on_error\n            This is a callback function that will be called when an error occurs.\n        on_close\n            A function that will be called when the websocket is closed.\n        on_open\n            This is a callback function that will be called when the connection is opened.\n        \"\"\"\nself.ws = None\nself.symbol = symbol\nself.token = token\nself.asset_type = asset_type\nself.url = self.get_ws_url() + \"/?token=\" + self.token\nself.on_message = on_message\nself.on_error = on_error\nself.on_close = on_close\nself.on_open = on_open\ndef get_ws_url(self):\n\"\"\"It takes the asset type and symbol and returns the websocket url\n        Returns\n        -------\n            The websocket url for the asset type and symbol.\n        \"\"\"\nreturn VinterUrl.websocket_url(self.asset_type, self.symbol)\ndef open(self):\n\"\"\"The function opens a websocket connection to the url specified in the constructor\"\"\"\nself.ws = websocket.WebSocketApp(\nself.url,\non_message=self.on_message,\non_error=self.on_error,\non_close=self.on_close,\non_open=self.on_open,\n)\nself.ws.run_forever()\ndef close(self):\n\"\"\"The function closes the websocket connection\"\"\"\nself.ws.close()\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_ws/#vinterunofficial.vinter_sdk_ws.VinterAPIWS.__init__","title":"<code>__init__(symbol, token, asset_type, on_message, on_error, on_close, on_open)</code>","text":"<p>The function takes in a symbol, token, asset type, and four callback functions. It then creates a websocket connection to the url for the symbol and asset type.</p>"},{"location":"vinterunofficial_doc/vinter_sdk_ws/#vinterunofficial.vinter_sdk_ws.VinterAPIWS.__init__--parameters","title":"Parameters","text":"<p>symbol     The symbol you want to subscribe to. token     Your API token. asset_type     The asset type of the symbol. on_message     This is the callback function that will be called when a message is received from the server. on_error     This is a callback function that will be called when an error occurs. on_close     A function that will be called when the websocket is closed. on_open     This is a callback function that will be called when the connection is opened.</p> Source code in <code>vinterunofficial/vinter_sdk_ws.py</code> <pre><code>def __init__(\nself, symbol, token, asset_type, on_message, on_error, on_close, on_open\n):\n\"\"\"The function takes in a symbol, token, asset type, and four callback functions. It then creates\n    a websocket connection to the url for the symbol and asset type.\n    Parameters\n    ----------\n    symbol\n        The symbol you want to subscribe to.\n    token\n        Your API token.\n    asset_type\n        The asset type of the symbol.\n    on_message\n        This is the callback function that will be called when a message is received from the server.\n    on_error\n        This is a callback function that will be called when an error occurs.\n    on_close\n        A function that will be called when the websocket is closed.\n    on_open\n        This is a callback function that will be called when the connection is opened.\n    \"\"\"\nself.ws = None\nself.symbol = symbol\nself.token = token\nself.asset_type = asset_type\nself.url = self.get_ws_url() + \"/?token=\" + self.token\nself.on_message = on_message\nself.on_error = on_error\nself.on_close = on_close\nself.on_open = on_open\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_ws/#vinterunofficial.vinter_sdk_ws.VinterAPIWS.close","title":"<code>close()</code>","text":"<p>The function closes the websocket connection</p> Source code in <code>vinterunofficial/vinter_sdk_ws.py</code> <pre><code>def close(self):\n\"\"\"The function closes the websocket connection\"\"\"\nself.ws.close()\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_ws/#vinterunofficial.vinter_sdk_ws.VinterAPIWS.get_ws_url","title":"<code>get_ws_url()</code>","text":"<p>It takes the asset type and symbol and returns the websocket url</p>"},{"location":"vinterunofficial_doc/vinter_sdk_ws/#vinterunofficial.vinter_sdk_ws.VinterAPIWS.get_ws_url--returns","title":"Returns","text":"<pre><code>The websocket url for the asset type and symbol.\n</code></pre> Source code in <code>vinterunofficial/vinter_sdk_ws.py</code> <pre><code>def get_ws_url(self):\n\"\"\"It takes the asset type and symbol and returns the websocket url\n    Returns\n    -------\n        The websocket url for the asset type and symbol.\n    \"\"\"\nreturn VinterUrl.websocket_url(self.asset_type, self.symbol)\n</code></pre>"},{"location":"vinterunofficial_doc/vinter_sdk_ws/#vinterunofficial.vinter_sdk_ws.VinterAPIWS.open","title":"<code>open()</code>","text":"<p>The function opens a websocket connection to the url specified in the constructor</p> Source code in <code>vinterunofficial/vinter_sdk_ws.py</code> <pre><code>def open(self):\n\"\"\"The function opens a websocket connection to the url specified in the constructor\"\"\"\nself.ws = websocket.WebSocketApp(\nself.url,\non_message=self.on_message,\non_error=self.on_error,\non_close=self.on_close,\non_open=self.on_open,\n)\nself.ws.run_forever()\n</code></pre>"}]}